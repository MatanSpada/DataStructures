תרגיל 1:
שורה:
33 מצהיר על vector_array כדי שבשורה 36 אוכל להשתמש בו.
34 - כנ"ל
36 - הקצאת הזיכרון של הטייפ החדש מסוג vector_t שיכיל את האלמנטים הנמצאים ב-struct.
42 - הקצאת זיכרון למערך עצמו שהוא חלק מה-struct.
45 - יכול להיות מקרה שבו ההקצאה של ה-new_vector תעבוד אבל ההקצאה של המערך/הוקטור לא תעבוד. 
לכן, לפני שאחזיר null, אדאג לשחרר את ההקצאה של ה- new_vector.


תרגיל 2:
שורה:
64+65 - משחרר את ההקצאה של הוקטור/מערך + דואג שלא ישאר דאנגלינג פוינטר.
67+68 - משחרר את הקצאת הזיכרון של משתנה הסטראקט מסוג vector_t בשם vector ודואג שלא ישאר דאנגלינג פוינטר.


תרגיל 3:
הרעיון הוא לקחת את ה- vector_array ולקדם אותו למיקום של האיבר המובקש על ידי קלט האינדקס, ואותו להחזיר.
מאחר ולא ניתן לבצע פוינטר אריתמטיקס על void (פעולות אריטמתיות כמו חיבור, חיסור וכו'), הפכתי את הוקטור ל-char
כי זה הכי מתאים מבחינת הקידום בבייטים. ואז אני מקדם את הפוינטר ב- אינקדס כפול גודל משתנה בבייטים.


תרגיל 4:
שורה:
90 - מצהיר על place_to_insert כי אשתמש בו תיכף להחזיק את המיקום שאליו נכניס איבר. למה לא עושה לו השמה כבר כאן?
כי אז, במידה וה- VectorReserve שבשורה 97 לא ימצא מקום רציף להגדיל את הזיכרון - הוא יחזיר לי כתובת אחרת לגמרי ואז
יווצר מצב שה- place_to_insert מצביע למקום הישן. - לכן אני רק מצהיר עליו למעלה ומבצע השמה לאחר ה- VectorReserve.
95 - במידה והיוזר מבקש להכניס איבר נוסף, אני בודק אם האיבר הזה הוא אחרון. אם כן, מגדיל את גודל המערך פי 2 על ידי
שימוש בפונקציית VectorReserve. הפונקציה מקבלת את הוקטור שאותו צריך להגדיל ואת הגודל הרצוי שהוא הגודל הנוכחי כפול 2.
100 - ה- place_to_insert מצביע לאיבר הראשון שבמערך/וקטור.
101 - מקדם אותו ב- כמות האיברים הנוכחית כפול גודל של כל איבר בבייטים. כרגע הוא מצביע למיקום שאחרי האיבר האחרון.
103 - משתמש ב-memcpy על מנת להעתיק את הערכים. 
הוא מעתיק vector->element_size שזה גודל של כל איבר בוקטור בבייטים, מתוך ה-element שהיוזר הביא, לתוך ה-buffer שזה
ה- place_to_insert, המצביע למיקום הבא הפנוי בוקטור.
106 - מחזיר הצלחה אם מצליח, ואם ה-reserve נכשל, יחזיר בתוך הפונקציה NULL.


תרגיל 5:
להוציא איבר.
117 - מקטין את כמות האיברים בוקטור ב-1.
119 - לפי דרישות הלקוח, אם קיים מצב שבו גודל המערך/הוקטור גדול או שווה לגודל האיברים במערך ביחס של 1/4 (פי 4), 
יש להקטין את גודל המערך/הוקטור לפי 2 מגודל האיברים.
לכן אם זה המצב, אני משתמש בכפל במקום בחילוק כי זה יותר מהר מחילוק לחישוב - ושולח את הוקטור לפוקנציה שתשנה אותו
לגודל המתאים. 
הפרמטרים לפונקציה הם הוקטור עצמו והגודל החדש הרצוי שהוא פי 2 מגודל האיברים, לכן current_size כפול 2.


תרגיל 6:
מחזיר את כמה האיברים הנוכחית בוקטור.


תרגיל 7:
מחזיר את גודל הוקטור/המערך.


תרגיל 8:
הפונקציה מקבלת את הוקטור ואת הגודל החדש המבוקש.
עושה ריאלוק ונותן את הארגומנטים של:
הוקטור/המערך, ואת הגודל הרצוי שזה ה- new_capacity כפול גודל כל איבר.
162 - במידה והצליח, מעדכן את ה-capacity החדש בוקטור.
164 - יש if שכל תפקידו הוא לאתר מקרים שבהם הקטנו את גודל המערך - ולבדוק - אם גודל המערך (ה- capacity) קטן יותר
מכמות האיברים - נקטין את כמות האיברים לגודל הוקטור/המערך החדש.

* יש להוסיף משתנה זמני שיחזיק את אותו הערך של הוקטור ואז עליו לעשות ריאלוק. במידה והריאלוק מצליח, להשוות לוקטור המקורי.
למה לעשות את זה? במידה והריאלוק נכשל הוא מחזיר NULL ואז הוקטור המקורי של היוזר נהרס (מצביע ל-NULL). 








 
